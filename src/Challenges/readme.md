# Interview Questions / Challenges


## Stack & Queues

1. Use an array to implement three stacks

2. Implement getMin or getMax method on your stack.

3. Create queue using 2 stacks 

4. Sort a stack with the min  values in order on top . You can use  anothe stack as buffer.

5. Write a function that returns true if a string of brackets is valid/balanced.


## Linked Lists 



1. Delete a node at the middle of the linked list.

2. A node with only a variable pointing at that node 


3. Delete duplicates

4. Write a function reversing a linked list
 / Can you do it in place ?

5. Check if  a linked list contains a cycle 

6. Find the kth to the last node



## Strings, Arrays , HashTables

1. Count the number of occurrences of all charecters or words in a body of text or string.


2. Delete duplicates in a list.

3. Find a unique value in a list.

4. Find if two integers in alist add up to k


5. Rotate a matrix string or an array

6. Given ab mxn boolean matrix if an element is 0 set its entire row and columnt to 0

7. Write a function ecnodes a string by turning all spaces into `%20`

8. Merge two sorted list into one list.

9. Searching for a value.



| Stack/ Queue    | Linked List    | Array/ String |                 |
|-----------------|----------------|---------------|-----------------|
| Reversing       | linear         | linear        | linear          |
| Sorting         | tower of Hanoi | not typical   | merge, quik     |
| Traversing      | not typical    | linear        | linear          |
| Merging, sorted | not typical    | linear        | linear          |
| Merging, range  | not typical    | not typical   | if sorted, O(n) |
| Interleaving    | not typical    | linear        | linear          |
| Partitioning    | not typical    | linear        | linear          |
| Rotating        | not typical    | linear        | linear          |
| Edit distance   | not typical    | not typical   | varies          |
| Shuffling       | not typical    | varies        | varies          |
| Searching         | linear         | linear         | linear        | linear         |
| Searching, sorted | log(n)         | log(n)         | NA            | log(n)         |
| Min/Max           | stack, O(1)    | stack, O(1)    | stack, O(1)   | stack, O(1)    |
| Min/Max, sorted   | in-place, O(1) | in-place, O(1) | NA            | in-place, O(1) |
| Unique            | HT, O(n)       | HT, O(n)       | default       | HT, O(n)       |
| Unique, sorted    | in-place, O(n) | in-place, O(n) | NA            | in-place, O(n) |
| Permutations      |                |                |               |                |


# Things to consider

in-place / side effects

preserving original order

Set vs Map vs Object

lengths of 0 and 1

off-by-ones

optimization vs readability

what other information could you ask for?